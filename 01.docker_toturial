常用的 Docker 命令
#一般來說，Docker 命令可以用來管理 daemon，或者透過 CLI 命令管理映像檔和容器。可以透過 man docker 來查看這些命令。
#Docker 的命令可以採用 docker-CMD 或者 docker CMD 的方式執行。兩者一致。

    列出所有 images

    docker images

    從 docker hub 搜尋3星以上 image

    docker search -s 3  <image-name>
    
    從 docker hub 取得 image
    
    docker pull <image-name>
    docker pull ubuntu
    docker pull centos

    列出所有正在執行的 containers

    docker ps

    列出所有運行中 containers

    要列出所有 containers 就要加上 -a 表示所有

    docker ps -a

    建立 images

    -t 表示待會建立的 image 我們給予一個 tag，之後我們就可以用該 tag 名稱來呼叫 image

    docker build -t <tag name> <path to Dockerfile>
    docker build -t testimage /test
    docker build -t testimage2 .

    執行 images

    -d 表示在背景執行
    --name 表示待會執行的 container 我們給予一個名字，比較方便之後指令呼叫
    -p 表示映射本機的 port 到容器裡面的 port
    -v 表示將本機的資料夾與容器的資料夾進行綁定

    dcoker run -d -p <host_port>:<container_port> <image_tag_name>
    docker run -d -p 80:8080 testimage

    docker run -d --name <container_name> <image_tag_name>
    docker run -d --name test_container testimage

    docker run -d -v <host_path>:<container_path> <image_tag_name>
    docker run -d -v ~/project:/usr/app testimage

    docker run -d --name test_container -p 80:8080 -v ~/project:/usr/app testimage
    
    docker run :
    不保留 container 的執行指令 :
    docker run 「–rm=ture」【image id】 /bin/echo ‘Hello world’
    「-t」讓Docker分配一個虛擬終端（pseudo-tty）並綁定到容器的標準輸入上，
    「-i」保持可輸入的狀態
    
    停止 container

    docker stop <container_name>
    docker stop test_container

    啟動 container

    docker start <container_name>
    docker start test_container

    刪除 container

    刪除 container 之前要先確認 container 已經停止
    docker rm <container_name / container_id>
    docker rm test_container
    docker rm e921d53c542b
    停止並刪除所有的 container
    docker stop $(docker ps -a -q) && docker rm $(docker ps -a -q)
    
    刪除 image

    docker rmi <image_tag / image_id>
    docker rmi test_image
    docker rmi 6a4d26175002

    將一個 containers 儲存成 image

    docker commit <container_id / container_name> <image_tag>
    docker commit test_container new_test_image

    匯出 image

    docker save <image_tag>
    docker save myimage | bzip2 -9 -c > myimage.tar.bz2
    docker save myimage > myimage.tar

    匯入 image

    docker load < <file_name>
    docker load myimage.tar
    bzip2 -d -c < myimage.tar.bz2 | docker load

    用 dockerfile 建 image :
    mkdir 【資料匣名稱】
    cd 【資料匣名稱】
    vi Dockerfile
    docker build -t=【新 image 的 name】
    
e.g.安裝 nodejs，用vim 寫一個 Dockerfile
===================================
#以什麼 image 為基礎
FROM ubuntu:14.04
#維護的名稱
MAINTAINER Xavier
#線上更新
RUN apt-get -qq update
#安裝 curl 
RUN apt-get -qqy install -y curl
#下載nodejs
RUN curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash –
#安裝
RUN apt-get install -y nodejs
#測試一下安裝後可不可以執行指令
RUN node -v
===================================
然後執行這個 Dockerfile 來建 image
# –rm 不會在建立好 image 同時建一個 container
# –t 設定 image 名稱
# 除非指定路徑名稱，不然最後不能少掉一個「 . 」，主要是用來指定路徑，表示為Dockerfile 所在的路徑
docker build –rm -t nodejs-xavier .
docker build –rm -t nodejs-xavier  【路徑】

然後建一個 container 執行指令
docker run -t -i 【image id】 node -v

如果要在建立時執行.js 檔，可以先把檔案 copy 到 container 裡
所以在 Dockerfile 加入
COPY xxx.js   /xxx.js
RUN node xxx.js


ps.
docker exec 【container id】【指令】可以進入「活」著的 container
一般我們在 container 執行的程式都不是常駐或是持續的，可能很快就結束
所以我一直會遇到錯誤訊息
Error response from daemon: Container ????  is not running
就是因為我的 container 不是活的，所以就算執行 docker start 也沒用
重點是，這個 container 還是持續在運行程式，比如有提供 web server 服務
或是我們用 docker run –name 【別名】 【image id】 ping localhost 來讓他持續 ping
再開一個視窗用 docker exec 連到這個 container 試試



=============================================
#命令
docker-attach(1)
    依附到一個正在執行的容器中。

docker-build(1)
    從一個 Dockerfile 建立一個映像檔

docker-commit(1)
    從一個容器的修改中建立一個新的映像檔

docker-cp(1)
    從容器中複製檔案到宿主系統中

docker-diff(1)
    檢查一個容器檔案系統的修改

docker-events(1)
    從服務端取得實時的事件

docker-export(1)
    匯出容器內容為一個 tar 包

docker-history(1)
    顯示一個映像檔的歷史

docker-images(1)
    列出存在的映像檔

docker-import(1)
    匯入一個檔案（典型為 tar 包）路徑或目錄來建立一個映像檔

docker-info(1)
    顯示一些相關的系統資訊

docker-inspect(1)
    顯示一個容器的底層具體資訊。

docker-kill(1)
    關閉一個執行中的容器 (包括程式和所有資源)

docker-load(1)
    從一個 tar 包中載入一個映像檔

docker-login(1)
    註冊或登錄到一個 Docker 的倉庫伺服器

docker-logout(1)
    從 Docker 的倉庫伺服器登出

docker-logs(1)
    取得容器的 log 資訊

docker-pause(1)
    暫停一個容器中的所有程式

docker-port(1)
    查找一個 nat 到一個私有網口的公共口

docker-ps(1)
    列出容器

docker-pull(1)
    從一個Docker的倉庫伺服器下拉一個映像檔或倉庫

docker-push(1)
    將一個映像檔或者倉庫推送到一個 Docker 的註冊伺服器

docker-restart(1)
    重新啟動一個執行中的容器

docker-rm(1)
    刪除指定的數個容器

docker-rmi(1)
    刪除指定的數個映像檔

docker-run(1)
    建立一個新容器，並在其中執行指定命令

docker-save(1)
    保存一個映像檔為 tar 包檔案

docker-search(1)
    在 Docker index 中搜索一個映像檔

docker-start(1)
    啟動一個容器

docker-stop(1)
    終止一個執行中的容器

docker-tag(1)
    為一個映像檔打標籤

docker-top(1)
    查看一個容器中的正在執行的程式資訊

docker-unpause(1)
    將一個容器內所有的程式從暫停狀態中恢復

docker-version(1)
    輸出 Docker 的版本資訊

docker-wait(1)
    阻塞直到一個容器終止，然後輸出它的退出符
===========================================
#選項
-D=true|false
    使用 debug 模式。預設為 false。

-H, --host=[unix:///var/run/docker.sock]: tcp://[host:port]來綁定或者 unix://[/path/to/socket] 來使用。
    在 daemon 模式下綁定的 socket，透過一個或多個 tcp://host:port, unix:///path/to/socket, fd://* or fd://socketfd 來指定。

--api-enable-cors=true|false
    在遠端 API 中啟用 CORS 頭。預設為 false。

-b=""
    將容器掛載到一個已存在的橋接器上。指定為 'none' 時則禁用容器的網路。

--bip=""
    讓動態建立的 docker0 採用指定的 CIDR 位址; 與 -b 選項互斥。

-d=true|false
    使用 daemon 模式。預設為 false。

--dns=""
    讓 Docker 使用指定的 DNS 伺服器。

-g=""
    指定 Docker 執行時的 root 路徑。預設為 /var/lib/docker。

--icc=true|false
    啟用容器間通信。預設為 true。

--ip=""
    綁定連接埠時候的預設 IP 位址。預設為 0.0.0.0。

--iptables=true|false
    禁止 Docker 新增 iptables 規則。預設為 true。

--mtu=VALUE
    指定容器網路的 mtu。預設為 1500。

-p=""
    指定 daemon 的 PID 檔案路徑。預設為 /var/run/docker.pid。

-s=""
    強制 Docker 執行時使用指定的儲存驅動。

-v=true|false
    輸出版本資訊並退出。預設值為 false。

--selinux-enabled=true|false
    啟用 SELinux 支援。預設值為 false。SELinux 目前不支援 BTRFS 儲存驅動。
======================================================================
#清除整個Docker的紀錄
關閉docker
$ /etc/init.d/docker stop
然後清掉docker檔案目錄下的所有東西
$ rm -rf /var/lib/docker/*
